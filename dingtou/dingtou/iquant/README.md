# 文件说明

主要是备份iquant/qmt中的脚本
这些脚本都是生产版本。

# 设计思路

QMT很难用，各种问题，我在[QMT趟坑记](http://book.piginzoo.com/knowledge/develope/qmt.html)中，已经详细地描述了。
这里仅记录实盘过程当中的一些设计思路和实现细节。

大体思路是：
- 策略写到[dingtou](https://github.com/piginzoo/quant_research/tree/main/dingtou)这个项目里，既是回测用，也是实盘的策略。
- 把dingtou pip install到本地，然后再QMT中import，然后QMT设置一个策略，每个1分钟来调用dingtou策略
- 如果dingtou策略给出了买信号，就用QMT下单，如果是卖信号，就用QMT卖掉股票，金额的大小都是策略告诉他的
- 为了监控服务器和QMT软件，我写了个心跳程序，定期发送心跳到我自己的云服务器，顺道也发送一些交易日志。

# 实盘机器：

我用的是一台零刻的mini主机，2000元（16G内存+500GSSD+6和12线程AMD）。主要是我发现云主机都太贵了，后来听朋友说有800元的，2核4G的，
我怎么就找不到呢？唉。所以才买了这个自己觉得性价比最高的，也最安全（防止被云端hack了）的机器，放置到家里。
也因为如此，我需要做一个监控。

机器上，我装了一个3.6.8，是为了解决给qmt安装额外的pip包。同时，我也装了一个python3.8，用于运行我的心跳程序。

我在bios中设置了周一到周五自动开机，每天9:15开机；在windows任务调度中，设置了15:15关机，让机器可以每天按时运行。

最后，还要在qmt中设置自动登录，自动启动心跳和etf这2个策略。

# 下单

下单用的是，passorder，它是qmt中最灵活的下单，我采用了按照金额下单的方式， 主要原因是我要买7支ETF基金，按照平均分配资金的原则来买的，
如果是按照固定股数，就会导致基金件资金分配不均。

但是采用资金下单，我当时就好奇，它会自动帮我买卖整手数么？答案是肯定的，比如我下单买或卖110元，股价是1元，那么只会成交100元，也就是买卖100手。
它会自动帮我取整到整手数。挺好，省的我自己算股数了。

另外，我用的卖2价来买，用买2价来卖，方便快速成交。

还有个问题，就是你必须要在bar的最后一个tick下单，才会生成买卖订单，之前的tick里下的都没用，这个特性很讨厌。
它又不提供类似于context.is_last_tick_of_bar之类的函数，我就没办法了，除非我一直在这个bar的所有tick都下单。
最后，我的办法是，使用passorder的quickTrade=1，来即刻触发下单，这个标志不等到下一个bar的第一个tick再创建订单了，而是立刻创建。
然后，我又做一个标志，如果下单了，就写个标志文件，就不再下单了。
这样做，虽然可以，但是，如果这单没成交，我就没有再check了，可能会有些问题，将来出问题再想办法吧。

但是，我也担心，这种即时下单的话，万一有bug，会导致不停地重复下单（靠bar的第一个tick触发交易，我还有机会补救，毕竟10分钟才一次），
但是如果是即时下单，3秒1个tick，就会触发交易，这太危险了。
所以，我不得不写了一个check机制，如果发现某只基金已经在今日交易记录中出现了3次，就不再交易它了。从而有效避免了重复下单。

下单成功的话，qmt会回调函数deal_callback，然后，会把这个新成交的记录保存下来，方便日后复盘。

>[参](https://zhuanlan.zhihu.com/p/587304791)：
> 当盘中运行到最后一根 K 线的时候，每个 tick 数据来时都会判定一下这个条件是否成立，当不 是这根 K 线的最后一个 tick，之前的所有的 tick 成立的产生的信号就是虚的信号。只有当这个 K 线确定 时，产生的信号才是有效信号，才会触发下单。

# 心跳

我写了一个服务器，用来监控QMT软件，和，服务器本身是否是好的。代码可以参考我的[quant_trader](https://github.com/piginzoo/quant_trader)项目，
我会让qmt把持仓、成交、市值等信息，推给服务器，然后服务器会保存到服务器上，可以方便后续我通过web端来查看，同时，每天都会生成一个文件，方便日后复盘。

我的监控程序有2个：
- qmt中的一个叫"心跳"的策略，这个策略，会把qmt中的持仓、交易信息，发送到我的云服务器上。
- 单独写了一个python的[hearbeat.py](https://github.com/piginzoo/quant_trader/blob/main/quant_trader/client/heartbeat.py)
把其他的额外信息，发送到云服务器。

我在服务器上开了个定时器，如果是周一到周五且是交易时间，如果发现超过超时时间（30分钟），就会触发报警，报警会推送微信、邮件等。
这样如果我的服务器有问题，我可以第一时间知道。

而且，我通过这个心跳，也可以即时地查看我的机器的信息和交易的信息。

# 云服务器

我有个云服务器，我部署了[quant_trader](https://github.com/piginzoo/quant_trader)这个服务。

这个服务接收来自我的mini电脑上的qmt和heartbeat.py发送来心跳和相关交易数据。
同时，这个服务启动一个调度器，调度器会监控心跳情况，发现qmt或heartbeat.py发来的心跳超时，就会启动报警发送给微信和邮件。

这个服务同时提供一个webUI，用来让我查看通过心跳发送来的qmt和mini电脑上的交易信息。

# 报警

目前，我写了3种报警：
- 邮件：使用了我的qq邮箱，好处是，新邮件到达的时候，微信的qq邮箱会自动提示，相当于是微信通知了
- 企业微信：之前公司用企业微信，还挺方便的，于是我就做了一个企业微信的发送，api支持也很好。不过也懒得折腾钉钉啥的了。
- [plusplus推送](https://www.pushplus.plus/)：是一个朋友推荐的支持微信推送的，还不错，免费的账号每个月200个消息，够用了。

# 数据

回测的时候，我用的是akshare的数据，也就是累计净值，其实，累计净值是一种后复权的方式，我回测用的就是这种后复权的方式。
我为什么不用前复权？因为akshare没有这个数据。

但是，实盘的时候，前复权和后复权的数据qmt都提供了，那我当然用前复权啦。因为，前复权的时候，和当前的价格是一致的，
这样，就不用再把当前的价格换算成复权价格了。即使用后复权触发了交易，提示给自己的消息也是个后复权的价格，
是和最新的价格是对不上的。
例如，成交后提示"今日后复权价格5.73，满足信号，触发交易"，但是，今日价格实际上是3.85，所以你根本对不上3.85和后复权价格5.73，
让人很迷惑。
后来，我都改成了前复权，我担心，会和后复权不一致，我专门做了比较，甚至画了图，发现结果是一致的，只有一致基金稍微有些出入。
所以，就用后复权测试，前复权跑实盘吧。


